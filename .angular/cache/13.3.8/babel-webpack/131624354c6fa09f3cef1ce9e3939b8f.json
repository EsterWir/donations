{"ast":null,"code":"import { BehaviorSubject, Subject, timer, Subscription, of } from 'rxjs';\nimport { map, distinctUntilChanged, tap, takeWhile, repeatWhen, share, take, filter, timeout, catchError } from 'rxjs/operators';\nimport { ɵɵdefineInjectable, Injectable, InjectionToken, Inject, Injector, ɵɵinject, NgModule } from '@angular/core';\nimport { HttpHeaders, HttpClient, HttpRequest, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { supportsPassiveEventListeners, supportsScrollBehavior, getRtlScrollAxisType, getSupportedInputTypes, Platform } from '@angular/cdk/platform';\n/**\r\n * Represents the different running environments.\r\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common/http';\nimport * as ɵngcc2 from '@angular/cdk/platform';\nvar UohEnvironment = /*#__PURE__*/(() => {\n  (function (UohEnvironment) {\n    UohEnvironment[\"Development\"] = \"dev\";\n    UohEnvironment[\"QA\"] = \"qa\";\n    UohEnvironment[\"Production\"] = \"\";\n  })(UohEnvironment || (UohEnvironment = {}));\n\n  return UohEnvironment;\n})();\n\n/**\r\n * Merge current state with new state using Object.assign function\r\n * @param currState current state\r\n * @param newState new state to merge with current state\r\n * @returns merged state+\r\n */\nconst objectAssignMergerFn = (currState, newState) => Object.assign({}, currState, newState);\n/**\r\n * Override function that simply returns the new state\r\n * @param _ current state\r\n * @param newState new state to override\r\n * @returns newState\r\n */\n\n\nconst overrideMergerFn = (_, newState) => newState;\n/**\r\n * Stores values to be used within a service or component.\r\n */\n\n\nclass UohStore {\n  /**\r\n   * Generates a new store.\r\n   * @param initialState The store initial state.\r\n   * @param storageKey The key to use to store the data in the browser. If undefined, the data won't be stored in the browser storage.\r\n   * @param storage The browser storage to use. Default: sessionStorage.\r\n   */\n  constructor(initialState, storageKey, storage = sessionStorage, mergerFn = objectAssignMergerFn) {\n    this.storageKey = storageKey;\n    this.storage = storage;\n    this.mergerFn = mergerFn;\n    this.initialState = this.storageKey ? this.getFromStorage(initialState, this.storageKey) : initialState;\n    this.store$ = new BehaviorSubject(this.initialState);\n    this.state$ = this.store$.asObservable();\n  }\n  /**\r\n   * Get the static value of the store's state.\r\n   * @returns The static value of the store.\r\n   */\n\n\n  getState() {\n    return this.store$.getValue();\n  }\n  /**\r\n   * Get the static value of a specific object inside the store's state.\r\n   * @param key A string representing a key in the state object.\r\n   */\n\n\n  getStateOf(key) {\n    return this.getState()[key];\n  }\n  /**\r\n   * Override the state of the store with a partial static object\r\n   * @param state A partial object containing updates for the state.\r\n   */\n\n\n  overrideState(state) {\n    this.setState(state, overrideMergerFn);\n  }\n  /**\r\n   * Update the state of the store by passing a partial static object.\r\n   * @param state A partial object containing updates for the state.\r\n   */\n\n\n  setState(state, mergerFn = this.mergerFn) {\n    // Use Object.assign to overcome an issue of typescript with the spread operator on generic types\n    this.store$.next(mergerFn(this.getState(), state));\n    this.save();\n  }\n  /**\r\n   * Get the observable representation of an object in the state.\r\n   * @param key A string representing a key in the state object.\r\n   */\n\n\n  select(key) {\n    return this.state$.pipe(map(state => state[key]), distinctUntilChanged());\n  }\n  /**\r\n   * Resets this store by resetting the initial state.\r\n   */\n\n\n  reset() {\n    this.store$.next(this.initialState);\n    this.clear();\n  }\n  /**\r\n   * Get the previously saved state in the session storage.\r\n   * @param initialState The initial state for the store\r\n   * @param key The storage key for the session storage\r\n   */\n\n\n  getFromStorage(initialState, key) {\n    const value = this.storage.getItem(key);\n    return value ? JSON.parse(value) : initialState;\n  }\n  /**\r\n   * Save the current state in the session storage.\r\n   */\n\n\n  save() {\n    if (!!this.storageKey) {\n      const state = this.getState();\n      this.storage.setItem(this.storageKey, JSON.stringify(state));\n    }\n  }\n  /**\r\n   * Clears the current session storage.\r\n   */\n\n\n  clear() {\n    if (!!this.storageKey) {\n      this.storage.removeItem(this.storageKey);\n    }\n  }\n\n}\n\nclass UohTimer {\n  /**\r\n   * Generates a new Timer that stops once the maximum time is reached.\r\n   * @param maxTime The maximum time.\r\n   */\n  constructor(maxTime) {\n    this.maxTime = maxTime;\n    this.start$ = new Subject();\n    /**\r\n     * Retrieves the current time of the timer.\r\n     * Fires each second the countdown from the maximum time.\r\n     * Stops when the timer is stopped and resets when it is started.\r\n     */\n\n    this.time$ = timer(0, 1000).pipe(map(time => this.maxTime - time), tap(time => time < 0 ? this.stop() : undefined), takeWhile(_ => this.active), repeatWhen(_ => this.start$), share());\n    this.stopped = new BehaviorSubject(true);\n    this.stopped$ = this.stopped.asObservable();\n  }\n  /**\r\n   * Whether the timer is ticking or not.\r\n   */\n\n\n  get active() {\n    return !this.stopped.getValue();\n  }\n  /**\r\n   * Starts the timer.\r\n   */\n\n\n  start() {\n    this.stopped.next(false);\n    this.start$.next();\n  }\n  /**\r\n   * Stops the timer.\r\n   */\n\n\n  stop() {\n    this.stopped.next(true);\n  }\n\n}\n\nvar UohLogLevel = /*#__PURE__*/(() => {\n  (function (UohLogLevel) {\n    UohLogLevel[UohLogLevel[\"FATAL\"] = 0] = \"FATAL\";\n    UohLogLevel[UohLogLevel[\"ERROR\"] = 1] = \"ERROR\";\n    UohLogLevel[UohLogLevel[\"WARN\"] = 2] = \"WARN\";\n    UohLogLevel[UohLogLevel[\"INFO\"] = 3] = \"INFO\";\n    UohLogLevel[UohLogLevel[\"DEBUG\"] = 4] = \"DEBUG\";\n    UohLogLevel[UohLogLevel[\"ALL\"] = 5] = \"ALL\";\n  })(UohLogLevel || (UohLogLevel = {}));\n\n  return UohLogLevel;\n})();\n\n/**\r\n * Validates Israeli IDs.\r\n */\nfunction idValidator() {\n  return control => {\n    if (control.value && control.value.length === 9 && !isNaN(control.value) && +control.value % 1 === 0) {\n      let counter = 0;\n\n      for (let i = 0; i < 9; i++) {\n        const digit = +control.value.charAt(i);\n        const weight = i % 2 + 1;\n        const weightedDigit = digit * weight;\n        counter += weightedDigit > 9 ? weightedDigit - 9 : weightedDigit;\n      } // If the sum of the weighted digits is divisible by 10 the id is valid.\n\n\n      if (counter % 10 === 0) {\n        return null;\n      }\n    } // Otherwise the id is invalid.\n\n\n    return {\n      id: true\n    };\n  };\n}\n\nlet UohDeactivateGuard = /*#__PURE__*/(() => {\n  class UohDeactivateGuard {\n    /**\r\n     * Checks if a component that implements the deactivable interface can be deactivated.\r\n     * @param component The deactivable component.\r\n     * @param currentRoute The current route.\r\n     * @param currentState The current router state.\r\n     * @param nextState The next router state.\r\n     */\n    canDeactivate(component, currentRoute, currentState, nextState) {\n      // The deactivation logic resides in the component itself.\n      return component.canDeactivate();\n    }\n\n  }\n\n  UohDeactivateGuard.ɵfac = function UohDeactivateGuard_Factory(t) {\n    return new (t || UohDeactivateGuard)();\n  };\n\n  UohDeactivateGuard.ɵprov = ɵɵdefineInjectable({\n    factory: function UohDeactivateGuard_Factory() {\n      return new UohDeactivateGuard();\n    },\n    token: UohDeactivateGuard,\n    providedIn: \"root\"\n  });\n  return UohDeactivateGuard;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Provides the url for the logger.\r\n */\n\n\nconst UOH_LOGGER_URL = new InjectionToken('The url were to send the UohLogger requests.');\n/**\r\n * Provides the log level for the logger.\r\n */\n\nconst UOH_LOGGER_LEVEL = new InjectionToken('The log level for the UohLogger.');\n/**\r\n * A header used to mark the requests sent by the UohLogger.\r\n */\n\nconst UOH_LOGGER_HEADER = 'uoh-logger';\n/**\r\n * Checks if a HTTP request was sent by the UohLogger (useful for interceptors).\r\n * @param request The HTTP request.\r\n * @returns True if the request was sent by the UohLogger, false otherwise.\r\n */\n\nconst isUohLogger = request => !!request.headers && !!request.headers.get(UOH_LOGGER_HEADER);\n/**\r\n * Logs values to a backend service.\r\n */\n\n\nlet UohLogger = /*#__PURE__*/(() => {\n  class UohLogger {\n    constructor(http, URL, level) {\n      this.http = http;\n      this.URL = URL;\n      this.level = level;\n      this.subscription = new Subscription();\n      this.level = !!level ? level : UohLogLevel.INFO;\n    }\n\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n    /**\r\n     * Logs values in the all level.\r\n     * @param values The comma separated values.\r\n     */\n\n\n    all(...values) {\n      this.log(UohLogLevel.ALL, ...values);\n    }\n    /**\r\n     * Logs values in the debug level.\r\n     * @param values The comma separated values.\r\n     */\n\n\n    debug(...values) {\n      this.log(UohLogLevel.DEBUG, ...values);\n    }\n    /**\r\n     * Logs values in the info level.\r\n     * @param values The comma separated values.\r\n     */\n\n\n    info(...values) {\n      this.log(UohLogLevel.INFO, ...values);\n    }\n    /**\r\n     * Logs values in the warn level.\r\n     * @param values The comma separated values.\r\n     */\n\n\n    warn(...values) {\n      this.log(UohLogLevel.WARN, ...values);\n    }\n    /**\r\n     * Logs values in the error level.\r\n     * @param values The comma separated values.\r\n     */\n\n\n    error(...values) {\n      this.log(UohLogLevel.ERROR, ...values);\n    }\n    /**\r\n     * Logs values in the fatal level.\r\n     * @param values The comma separated values.\r\n     */\n\n\n    fatal(...values) {\n      this.log(UohLogLevel.FATAL, ...values);\n    }\n    /**\r\n     * Prints the given values to log.\r\n     * @param level The log level.\r\n     * @param values The values to log.\r\n     */\n\n\n    log(level, ...values) {\n      // Send the log request only if the level is greater or equal to the level configured in the module.\n      if (level <= this.level) {\n        // Get the name of the key in the log level enum to send it in the request.\n        const levelName = UohLogLevel[level];\n        const message = this.concatenate(values);\n        const log = {\n          level: levelName,\n          message\n        };\n        this.post(this.URL, JSON.stringify(log));\n      }\n    }\n    /**\r\n     * Posts the given content to the given url.\r\n     * @param url The url to post to.\r\n     * @param content The content to post.\r\n     */\n\n\n    post(url, content) {\n      const headers = new HttpHeaders().set(UOH_LOGGER_HEADER, 'true');\n      this.subscription.add(this.http.post(url, content, {\n        headers\n      }).pipe(take(1)).subscribe());\n    }\n    /**\r\n     * Concatenates an array of string values.\r\n     * @param values The array of values.\r\n     */\n\n\n    concatenate(values) {\n      return values.join(' ');\n    }\n\n  }\n\n  UohLogger.ɵfac = function UohLogger_Factory(t) {\n    return new (t || UohLogger)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(UOH_LOGGER_URL), ɵngcc0.ɵɵinject(UOH_LOGGER_LEVEL));\n  };\n\n  UohLogger.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: UohLogger,\n    factory: UohLogger.ɵfac\n  });\n  return UohLogger;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet UohLogRequestsInterceptor = /*#__PURE__*/(() => {\n  class UohLogRequestsInterceptor {\n    /**\r\n     * ApiInterceptor constructor\r\n     *\r\n     * @param injector\r\n     */\n    constructor(injector) {\n      this.injector = injector;\n    }\n    /**\r\n     * Get injected HttpClient\r\n     */\n\n\n    get http() {\n      return this.injector.get(HttpClient);\n    }\n    /**\r\n     * Get injected UohLogger\r\n     */\n\n\n    get logger() {\n      return this.injector.get(UohLogger);\n    }\n    /**\r\n     *\r\n     * @param request\r\n     * @param next\r\n     * @returns {Ovservable<any>}\r\n     */\n\n\n    intercept(request, next) {\n      const clone = request.clone();\n      const headers = clone.headers;\n      const shouldLog = headers.get(UohLogRequestsInterceptor.SHOULD_LOG_REQUEST_HEADER);\n\n      if (shouldLog) {\n        this.logger.debug('[LogRequestsInterceptors.intercept] request: ', clone.urlWithParams, ', body: ', JSON.stringify(clone.body));\n      }\n\n      return next.handle(clone);\n    }\n\n  }\n\n  UohLogRequestsInterceptor.ɵfac = function UohLogRequestsInterceptor_Factory(t) {\n    return new (t || UohLogRequestsInterceptor)(ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  UohLogRequestsInterceptor.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: UohLogRequestsInterceptor,\n    factory: UohLogRequestsInterceptor.ɵfac\n  });\n  UohLogRequestsInterceptor.SHOULD_LOG_REQUEST_HEADER = 'Uoh-Interceptor-Log-Requests-Should-Log-Reqeust';\n  return UohLogRequestsInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Handles http errors and displays them into the app-error component.\r\n */\n\n\nlet UohErrorHandlerService = /*#__PURE__*/(() => {\n  class UohErrorHandlerService {\n    constructor() {\n      this.initialState = {\n        label: null,\n        message: ''\n      };\n      this.state = new BehaviorSubject(this.initialState);\n      this.state$ = this.state.asObservable();\n    }\n    /**\r\n     * Handles an http error, displays the error message and returns an Observable of the given output object (for the Observable catchError).\r\n     * @param error The http error.\r\n     * @param output The object to return after the error is handled.\r\n     * @param label The error label for the display.\r\n     */\n\n\n    handle(label = null, message = '') {\n      this.set(message, label);\n    }\n    /**\r\n     * Sets an error message to be displayed in the app-error component with given label.\r\n     * @param message The error message.\r\n     * @param label The error label for the display.\r\n     */\n\n\n    set(message, label = null) {\n      this.state.next({\n        message,\n        label\n      });\n    }\n    /**\r\n     * Retrieves the error message stored under the given label.\r\n     * @param label The error label for the display.\r\n     */\n\n\n    select(label = null) {\n      return this.state$.pipe(filter(state => !label || state.label === label), map(state => state.message));\n    }\n    /**\r\n     * Clears the error messages under the given label.\r\n     * @param label The error label for the display.\r\n     */\n\n\n    clear(label = null) {\n      this.state.next(Object.assign(Object.assign({}, this.initialState), {\n        label\n      }));\n    }\n    /**\r\n     * Returns true if any error messages were registered, false otherwise.\r\n     */\n\n\n    hasErrors() {\n      return !!this.state.getValue();\n    }\n\n  }\n\n  UohErrorHandlerService.ɵfac = function UohErrorHandlerService_Factory(t) {\n    return new (t || UohErrorHandlerService)();\n  };\n\n  UohErrorHandlerService.ɵprov = ɵɵdefineInjectable({\n    factory: function UohErrorHandlerService_Factory() {\n      return new UohErrorHandlerService();\n    },\n    token: UohErrorHandlerService,\n    providedIn: \"root\"\n  });\n  return UohErrorHandlerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar ErrorType = /*#__PURE__*/(() => {\n  (function (ErrorType) {\n    ErrorType[\"GENERAL_ERROR\"] = \"GENERAL_ERROR\";\n    ErrorType[\"INPUT_ERROR\"] = \"INPUT_ERROR\";\n    ErrorType[\"OUTPUT_ERROR\"] = \"OUTPUT_ERROR\";\n  })(ErrorType || (ErrorType = {}));\n\n  return ErrorType;\n})();\n\n/**\r\n * Handles http errors and displays them into the app-error component.\r\n */\nlet UohHttpErrorHandlerService = /*#__PURE__*/(() => {\n  class UohHttpErrorHandlerService {\n    constructor(logger, errorHandler) {\n      this.logger = logger;\n      this.errorHandler = errorHandler;\n    }\n    /**\r\n     * Handles an http error, displays the error message and returns an Observable of the given output object (for the Observable catchError).\r\n     * @param error The http error.\r\n     * @param output The object to return after the error is handled.\r\n     * @param label The error label for the display.\r\n     */\n\n\n    handle(error, output, label = null, message = '') {\n      const [errorMessage, params] = this.parseMessage(error);\n      this.errorHandler.handle(label, message || errorMessage);\n      console.error('[ErrorHandlerService.handle] Label: ', label || 'null', 'message: ', errorMessage, 'params: ', JSON.stringify(params));\n      this.logger.error('[ErrorHandlerService.handle] Label: ', label || 'null', 'message: ', errorMessage, 'params: ', JSON.stringify(params));\n      return of(output);\n    }\n    /**\r\n     * Retrieves the error message returned by the server (it may return a json object).\r\n     * @param error The http error.\r\n     */\n\n\n    parseMessage(error) {\n      let message = ErrorType.GENERAL_ERROR;\n\n      try {\n        // Try to get the error as a json object.\n        if (error.error) {\n          let apiError = error.error;\n\n          if (apiError.validation === true) {\n            apiError = apiError;\n            message = ErrorType.INPUT_ERROR;\n          } else if (apiError.bapi) {\n            apiError = apiError;\n            message = apiError.message;\n          } else {\n            apiError = apiError;\n          }\n\n          return [message, apiError];\n        }\n      } catch (e) {} // The error message is plain text\n\n\n      return [message, error];\n    }\n    /**\r\n     * Retrieves the error message stored under the given label.\r\n     * @param label The error label for the display.\r\n     */\n\n\n    select(label) {\n      return this.errorHandler.select(label);\n    }\n    /**\r\n     * Clears the error messages under the given label.\r\n     * @param label The error label for the display.\r\n     */\n\n\n    clear(label = null) {\n      return this.errorHandler.clear(label);\n    }\n    /**\r\n     * Returns true if any error messages were registered, false otherwise.\r\n     */\n\n\n    hasErrors() {\n      return this.errorHandler.hasErrors();\n    }\n\n  }\n\n  UohHttpErrorHandlerService.ɵfac = function UohHttpErrorHandlerService_Factory(t) {\n    return new (t || UohHttpErrorHandlerService)(ɵngcc0.ɵɵinject(UohLogger), ɵngcc0.ɵɵinject(UohErrorHandlerService));\n  };\n\n  UohHttpErrorHandlerService.ɵprov = ɵɵdefineInjectable({\n    factory: function UohHttpErrorHandlerService_Factory() {\n      return new UohHttpErrorHandlerService(ɵɵinject(UohLogger), ɵɵinject(UohErrorHandlerService));\n    },\n    token: UohHttpErrorHandlerService,\n    providedIn: \"root\"\n  });\n  return UohHttpErrorHandlerService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet UohErrorHandlingInterceptor = /*#__PURE__*/(() => {\n  class UohErrorHandlingInterceptor {\n    /**\r\n     * ApiInterceptor constructor\r\n     *\r\n     * @param injector\r\n     */\n    constructor(injector) {\n      this.injector = injector;\n    }\n    /**\r\n     * Get injected HttpErrorHandlerService\r\n     */\n\n\n    get errorHandler() {\n      return this.injector.get(UohHttpErrorHandlerService);\n    }\n    /**\r\n     * Intercept\r\n     * @param request\r\n     * @param next\r\n     * @returns {Ovservable<any>}\r\n     */\n\n\n    intercept(request, next) {\n      let defualtResponse = {};\n      const clone = request.clone();\n      const headers = clone.headers;\n      const label = headers.get(UohErrorHandlingInterceptor.LABEL_HEADER);\n      const shouldHandle = headers.get(UohErrorHandlingInterceptor.SHOULD_HANDLE_HEADER);\n      const defResParam = headers.get(UohErrorHandlingInterceptor.DEFAULT_RESPONSE_HEADER);\n\n      if (defResParam === null || defResParam === void 0 ? void 0 : defResParam.length) {\n        defualtResponse = JSON.parse(defResParam);\n      }\n\n      return next.handle(clone).pipe(timeout(10000), catchError(error => {\n        if (shouldHandle === 'true') {\n          return this.errorHandler.handle(error, defualtResponse, label);\n        }\n\n        return of(error);\n      }));\n    }\n\n  }\n\n  UohErrorHandlingInterceptor.ɵfac = function UohErrorHandlingInterceptor_Factory(t) {\n    return new (t || UohErrorHandlingInterceptor)(ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  UohErrorHandlingInterceptor.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: UohErrorHandlingInterceptor,\n    factory: UohErrorHandlingInterceptor.ɵfac\n  });\n  UohErrorHandlingInterceptor.LABEL_HEADER = 'Uoh-Interceptor-Error-Handling-Label';\n  UohErrorHandlingInterceptor.SHOULD_HANDLE_HEADER = 'Uoh-Interceptor-Error-Handler-Should-Handle';\n  UohErrorHandlingInterceptor.DEFAULT_RESPONSE_HEADER = 'Uoh-Interceptor-Error-Handler-Default-Response';\n  return UohErrorHandlingInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst UOH_MOCK_REQUESTS = new InjectionToken('');\nlet UohMockRequestInterceptor = /*#__PURE__*/(() => {\n  class UohMockRequestInterceptor {\n    /**\r\n     * ApiInterceptor constructor\r\n     *\r\n     * @param injector\r\n     */\n    constructor(injector) {\n      this.injector = injector;\n    }\n    /**\r\n     * Get injected ConfigurationService\r\n     */\n\n\n    get http() {\n      return this.injector.get(HttpClient);\n    }\n    /**\r\n     * Get injected ConfigurationService\r\n     */\n\n\n    shouldMockRequests() {\n      return this.injector.get(UOH_MOCK_REQUESTS);\n    }\n    /**\r\n     *\r\n     * @param request\r\n     * @param next\r\n     * @returns {Ovservable<any>}\r\n     */\n\n\n    intercept(request, next) {\n      const clone = request.clone();\n      const headers = clone.headers;\n      const dummyDataPath = headers.get(UohMockRequestInterceptor.DUMMY_DATA_PATH_HEADER);\n\n      if (!this.shouldMockRequests() || !dummyDataPath) {\n        return next.handle(clone);\n      }\n\n      return next.handle(new HttpRequest(request.method, dummyDataPath));\n    }\n\n  }\n\n  UohMockRequestInterceptor.ɵfac = function UohMockRequestInterceptor_Factory(t) {\n    return new (t || UohMockRequestInterceptor)(ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  UohMockRequestInterceptor.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: UohMockRequestInterceptor,\n    factory: UohMockRequestInterceptor.ɵfac\n  });\n  UohMockRequestInterceptor.DUMMY_DATA_PATH_HEADER = 'Uoh-Interceptor-Mock-Request-Dummy-Data-Path';\n  return UohMockRequestInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst UOH_ORIGIN_URL = new InjectionToken('');\nlet UohOriginUrlInterceptor = /*#__PURE__*/(() => {\n  class UohOriginUrlInterceptor {\n    /**\r\n     * ApiInterceptor constructor\r\n     *\r\n     * @param injector\r\n     */\n    constructor(injector) {\n      this.injector = injector;\n    }\n    /**\r\n     * Get injected ConfigurationService\r\n     */\n\n\n    get http() {\n      return this.injector.get(HttpClient);\n    }\n    /**\r\n     * Get injected origin url\r\n     */\n\n\n    get originUrl() {\n      return this.injector.get(UOH_ORIGIN_URL);\n    }\n    /**\r\n     * Intercept\r\n     * @param request\r\n     * @param next\r\n     * @returns {Ovservable<any>}\r\n     */\n\n\n    intercept(request, next) {\n      let clone;\n      const url = request.url;\n      const headers = request.headers;\n      const shouldUseOriginUrl = headers.get(UohOriginUrlInterceptor.SHOULD_USE_ORIGIN_URL_HEADER);\n      const originURL = this.originUrl;\n\n      if (shouldUseOriginUrl != 'false' && (url[0] === '/' || url[0] === '\\\\')) {\n        clone = request.clone({\n          url: `${originURL}${request.url}`\n        });\n      } else {\n        clone = request.clone();\n      }\n\n      return next.handle(clone);\n    }\n\n  }\n\n  UohOriginUrlInterceptor.ɵfac = function UohOriginUrlInterceptor_Factory(t) {\n    return new (t || UohOriginUrlInterceptor)(ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  UohOriginUrlInterceptor.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: UohOriginUrlInterceptor,\n    factory: UohOriginUrlInterceptor.ɵfac\n  });\n  UohOriginUrlInterceptor.SHOULD_USE_ORIGIN_URL_HEADER = 'Uoh-Interceptor-Origin-Url-Should-Use-Origin-Url';\n  return UohOriginUrlInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Provides the browser's window object.\r\n */\n\n\nconst WINDOW = new InjectionToken('The window this app is running on.');\n/**\r\n * Retrieves information about the platform running this app.\r\n */\n// The following comment (dynamic) avoids Window type errors on \"strictMetadataEmit\": true\n\n/** @dynamic */\n\nlet UohPlatform = /*#__PURE__*/(() => {\n  class UohPlatform {\n    constructor(platform, window, document) {\n      this.platform = platform;\n      this.window = window;\n      this.document = document;\n    }\n    /**\r\n     * Retrieves textual information about the client platform.\r\n     */\n\n\n    getInfo() {\n      const supportedInputTypes = this.getSupportedInputTypes();\n      const passiveEventListeners = supportsPassiveEventListeners();\n      const scrollBehavior = supportsScrollBehavior();\n      const rtlScrollAxisType = getRtlScrollAxisType();\n      const windowScreen = this.getWindowScreenInfo();\n      const documentScreen = this.getDocumentScreenInfo();\n      const browser = this.getBrowserInfo();\n      const url = !!this.document ? this.document.URL : '';\n      const info = 'Platform Information:' + ` URL: ${url},` + ` Browser: ${this.platform.isBrowser},` + ` Android: ${this.platform.ANDROID},` + ` iOS: ${this.platform.IOS},` + ` Firefox: ${this.platform.FIREFOX},` + ` Blink: ${this.platform.BLINK},` + ` Webkit: ${this.platform.WEBKIT},` + ` Trident: ${this.platform.TRIDENT},` + ` Edge: ${this.platform.EDGE},` + ` Safari: ${this.platform.SAFARI},` + ` Supported input types: ${supportedInputTypes},` + ` Supports passive event listeners: ${passiveEventListeners},` + ` Supports scroll behavior: ${scrollBehavior},` + ` RTL scroll axis type: ${rtlScrollAxisType},` + ` ${windowScreen},` + ` ${documentScreen},` + ` ${browser}`;\n      return info;\n    }\n    /**\r\n     * Retrieves the document width or -1 if undefined.\r\n     */\n\n\n    getDocumentWidth() {\n      if (!this.document) {\n        return -1;\n      } // Get the max width between the body and the document element.\n\n\n      const body = this.getMaxWidth(this.document.body);\n      const html = this.getMaxWidth(this.document.documentElement);\n      return Math.max(body, html);\n    }\n    /**\r\n     * Retrieves the document height or -1 if undefined.\r\n     */\n\n\n    getDocumentHeight() {\n      if (!this.document) {\n        return -1;\n      } // Get the max height between the body and the document element.\n\n\n      const body = this.getMaxHeight(this.document.body);\n      const html = this.getMaxHeight(this.document.documentElement);\n      return Math.max(body, html);\n    }\n    /**\r\n     * Returns the maximum width for the given element (from scroll, offset and client widths).\r\n     * @param element The HTML element.\r\n     * @returns The maximum width for the given element or -1 if undefined.\r\n     */\n\n\n    getMaxWidth(element) {\n      if (!element) {\n        return -1;\n      }\n\n      const scrollWidth = !!element.scrollWidth ? element.scrollWidth : -1;\n      const offsetWidth = !!element.offsetWidth ? element.offsetWidth : -1;\n      const clientWidth = !!element.clientWidth ? element.clientWidth : -1;\n      return Math.max(scrollWidth, offsetWidth, clientWidth);\n    }\n    /**\r\n     * Returns the maximum height for the given element (from scroll, offset and client heights).\r\n     * @param element The HTML element.\r\n     * @returns The maximum height for the given element or -1 if undefined.\r\n     */\n\n\n    getMaxHeight(element) {\n      if (!element) {\n        return -1;\n      }\n\n      const scrollHeight = !!element.scrollHeight ? element.scrollHeight : -1;\n      const offsetHeight = !!element.offsetHeight ? element.offsetHeight : -1;\n      const clientHeight = !!element.clientHeight ? element.clientHeight : -1;\n      return Math.max(scrollHeight, offsetHeight, clientHeight);\n    }\n    /**\r\n     * Retrieves textual information about the document width and height.\r\n     */\n\n\n    getDocumentScreenInfo() {\n      if (!this.document) {\n        return '';\n      }\n\n      const width = this.getDocumentWidth();\n      const height = this.getDocumentHeight();\n      return `Document width: ${width}, Document height: ${height}`;\n    }\n    /**\r\n     * Retrieves the window screen information.\r\n     */\n\n\n    getWindowScreenInfo() {\n      if (!this.window) {\n        return '';\n      }\n\n      const basic = `Inner width: ${this.window.innerWidth}, Inner height: ${this.window.innerHeight}`;\n      return !!this.window.screen ? `Width: ${this.window.screen.width},` + ` Height: ${this.window.screen.height},` + ` Available width: ${this.window.screen.availWidth},` + ` Available height: ${this.window.screen.availHeight},` + ` ${basic}` : basic;\n    }\n    /**\r\n     * Retrieves the browser details.\r\n     */\n\n\n    getBrowserInfo() {\n      if (!this.window) {\n        return '';\n      }\n\n      return `Browser Vendor: ${this.window.navigator.vendor}, User Agent: ${this.window.navigator.userAgent}, Platform: ${this.window.navigator.platform}`;\n    }\n    /**\r\n     * Retrieves the list of supported input types by the browser.\r\n     */\n\n\n    getSupportedInputTypes() {\n      return Array.from(getSupportedInputTypes()).join(', ');\n    }\n\n  }\n\n  UohPlatform.ɵfac = function UohPlatform_Factory(t) {\n    return new (t || UohPlatform)(ɵngcc0.ɵɵinject(ɵngcc2.Platform), ɵngcc0.ɵɵinject(WINDOW), ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n\n  UohPlatform.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: UohPlatform,\n    factory: UohPlatform.ɵfac\n  });\n  return UohPlatform;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Retrieves the environment the app is currently running on.\r\n * @param document The HTML document.\r\n */\n\n\nfunction getEnvironment(document) {\n  if (document.location.hostname.includes(UohEnvironment.Development)) {\n    return UohEnvironment.Development;\n  } else if (document.location.hostname.includes(UohEnvironment.QA)) {\n    return UohEnvironment.QA;\n  } else {\n    return UohEnvironment.Production;\n  }\n}\n/**\r\n * A token to inject the running environment.\r\n */\n\n\nconst UOH_ENVIRONMENT = new InjectionToken('The environment this app is running on.');\n/**\r\n * A factory that injects the running environment.\r\n */\n\nconst UOH_ENVIRONMENT_FACTORY = {\n  provide: UOH_ENVIRONMENT,\n  useFactory: getEnvironment,\n  deps: [DOCUMENT]\n};\nlet UohEnvironmentModule = /*#__PURE__*/(() => {\n  class UohEnvironmentModule {}\n\n  UohEnvironmentModule.ɵfac = function UohEnvironmentModule_Factory(t) {\n    return new (t || UohEnvironmentModule)();\n  };\n\n  UohEnvironmentModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: UohEnvironmentModule\n  });\n  UohEnvironmentModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [UOH_ENVIRONMENT_FACTORY],\n    imports: [[CommonModule]]\n  });\n  return UohEnvironmentModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(UohEnvironmentModule, {\n    imports: function () {\n      return [CommonModule];\n    }\n  });\n})();\n\nlet UohLoggerModule = /*#__PURE__*/(() => {\n  class UohLoggerModule {\n    /**\r\n     * Configures the UohLoggerModule.\r\n     * @param url The url to send the logs to.\r\n     * @param level The log level for the client.\r\n     * @param useClass The class to use as logger. You can extend the UohLogger and use your own.\r\n     * @returns The UohLoggerModule with the providers.\r\n     */\n    static forRoot(url, level, useClass = UohLogger) {\n      return {\n        ngModule: UohLoggerModule,\n        providers: [{\n          provide: UOH_LOGGER_URL,\n          useValue: url\n        }, {\n          provide: UOH_LOGGER_LEVEL,\n          useValue: level\n        }, {\n          provide: UohLogger,\n          useClass\n        }]\n      };\n    }\n\n  }\n\n  UohLoggerModule.ɵfac = function UohLoggerModule_Factory(t) {\n    return new (t || UohLoggerModule)();\n  };\n\n  UohLoggerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: UohLoggerModule\n  });\n  UohLoggerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return UohLoggerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst ɵ0 = window;\nlet UohPlatformModule = /*#__PURE__*/(() => {\n  class UohPlatformModule {}\n\n  UohPlatformModule.ɵfac = function UohPlatformModule_Factory(t) {\n    return new (t || UohPlatformModule)();\n  };\n\n  UohPlatformModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: UohPlatformModule\n  });\n  UohPlatformModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [{\n      provide: WINDOW,\n      useValue: ɵ0\n    }, {\n      provide: UohPlatform,\n      useClass: UohPlatform\n    }],\n    imports: [[CommonModule]]\n  });\n  return UohPlatformModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(UohPlatformModule, {\n    imports: function () {\n      return [CommonModule];\n    }\n  });\n})();\n\nconst UOH_REQUEST_DEFAULT_OPTIONS = {\n  originUrl: '',\n  mockRequests: false\n};\nlet UohRequestModule = /*#__PURE__*/(() => {\n  class UohRequestModule {\n    /**\r\n     * Configures UohRequestModule and provide request interceptors\r\n     * @param overrides Override request module options\r\n     * @returns UohRequestModule with necessary providers\r\n     */\n    static forRoot(overrides = {}) {\n      const options = Object.assign(Object.assign({}, UOH_REQUEST_DEFAULT_OPTIONS), overrides);\n      return {\n        ngModule: UohRequestModule,\n        providers: [{\n          provide: UOH_ORIGIN_URL,\n          useValue: options.originUrl\n        }, {\n          provide: UOH_MOCK_REQUESTS,\n          useValue: options.mockRequests\n        }, {\n          provide: HTTP_INTERCEPTORS,\n          useClass: UohOriginUrlInterceptor,\n          multi: true\n        }, {\n          provide: HTTP_INTERCEPTORS,\n          useClass: UohMockRequestInterceptor,\n          multi: true\n        }, {\n          provide: HTTP_INTERCEPTORS,\n          useClass: UohLogRequestsInterceptor,\n          multi: true\n        }, {\n          provide: HTTP_INTERCEPTORS,\n          useClass: UohErrorHandlingInterceptor,\n          multi: true\n        }]\n      };\n    }\n\n  }\n\n  UohRequestModule.ɵfac = function UohRequestModule_Factory(t) {\n    return new (t || UohRequestModule)();\n  };\n\n  UohRequestModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: UohRequestModule\n  });\n  UohRequestModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return UohRequestModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\r\n * Public API Surface of ngx-tools\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { ErrorType, UOH_ENVIRONMENT, UOH_ENVIRONMENT_FACTORY, UOH_LOGGER_HEADER, UOH_LOGGER_LEVEL, UOH_LOGGER_URL, UOH_MOCK_REQUESTS, UOH_ORIGIN_URL, UOH_REQUEST_DEFAULT_OPTIONS, UohDeactivateGuard, UohEnvironment, UohEnvironmentModule, UohErrorHandlerService, UohErrorHandlingInterceptor, UohHttpErrorHandlerService, UohLogLevel, UohLogRequestsInterceptor, UohLogger, UohLoggerModule, UohMockRequestInterceptor, UohOriginUrlInterceptor, UohPlatform, UohPlatformModule, UohRequestModule, UohStore, UohTimer, WINDOW, getEnvironment, idValidator, isUohLogger, objectAssignMergerFn, overrideMergerFn, ɵ0 }; //# sourceMappingURL=haifauniversity-ngx-tools.js.map","map":null,"metadata":{},"sourceType":"module"}